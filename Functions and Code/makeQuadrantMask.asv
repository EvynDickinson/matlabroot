
% Define square image dimensions
imageSize = 256;  % Size of the square image
radius = imageSize / 4;  % Radius of the circle
center = [imageSize / 2, imageSize / 2];  % Center of the circle

% Create a logical mask for the circle
[X, Y] = meshgrid(1:imageSize, 1:imageSize);
circleMask = (X - center(1)).^2 + (Y - center(2)).^2 <= radius^2;

% Define the diagonal quadrant boundaries (forming an "X")
% Quadrant 1: Top-left (Y > X)
% Quadrant 2: Top-right (Y > -X + 2 * center(1))
% Quadrant 3: Bottom-right (Y <= X)
% Quadrant 4: Bottom-left (Y <= -X + 2 * center(1))
quadrant1Mask = circleMask & (Y > X) & (Y > -X + 2 * center(1));   % Top-left
quadrant2Mask = circleMask & (Y > X) & (Y <= -X + 2 * center(1));  % Top-right
quadrant3Mask = circleMask & (Y <= X) & (Y <= -X + 2 * center(1)); % Bottom-right
quadrant4Mask = circleMask & (Y <= X) & (Y > -X + 2 * center(1));  % Bottom-left

% Calculate the ROI X and Y positions for each quadrant
[Q1_Y, Q1_X] = find(quadrant1Mask);
[Q2_Y, Q2_X] = find(quadrant2Mask);
[Q3_Y, Q3_X] = find(quadrant3Mask);
[Q4_Y, Q4_X] = find(quadrant4Mask);

% Plot the circle and quadrants for visualization
figure;
imshow(circleMask); hold on;
plot(Q1_X, Q1_Y, 'r.', 'DisplayName', 'Quadrant 1 (Top-left)');
plot(Q2_X, Q2_Y, 'g.', 'DisplayName', 'Quadrant 2 (Top-right)');
plot(Q3_X, Q3_Y, 'b.', 'DisplayName', 'Quadrant 3 (Bottom-right)');
plot(Q4_X, Q4_Y, 'm.', 'DisplayName', 'Quadrant 4 (Bottom-left)');
legend('show');
title('Circle Divided into Quadrants Forming an X');


%% Overlay and test the quadrant mask:
clearvars('-except',initial_vars{:})

for exp = 1:num.exp
    for trial = 1:num.trial(exp)
        center = data(exp).data(trial).data.centre;
        x_loc = data(exp).data(trial).data.x_loc;
        y_loc = data(exp).data(trial).data.y_loc;
        r = data(exp).data(trial).data.r;
        foodWell = data(exp).T.foodLoc(trial);

        % Adjust the X and Y coordinates relative to the new center
        adjustedX = x_loc - center(1);
        adjustedY = y_loc - center(2);
        
        % Initialize matrix to hold quadrant classification (same size as input matrices)
        quadrantMatrix = zeros(size(x_loc));
        
        % Define quadrant masks based on the new center
        Q = [];
        Q(1).Mask = (adjustedY > adjustedX) & (adjustedY <= -adjustedX);  % Top
        Q(2).Mask = (adjustedY <= adjustedX) & (adjustedY <= -adjustedX); % Bottom
        Q(3).Mask = (adjustedY <= adjustedX) & (adjustedY > -adjustedX);  % Left
        Q(4).Mask = (adjustedY > adjustedX) & (adjustedY > -adjustedX);   % Right
        
        % Determine the well locations (which determine quadrant assignment):
        adjusted_wx = data(exp).data(trial).data.wellcenters(1,foodWell) - center(1);
        adjusted_wy = data(exp).data(trial).data.wellcenters(2,foodWell) - center(2);
        
        idx_loc = false(1,4);
        % Find the food quadrant (find location with the food well coordinates included)
        idx_loc(1) = (adjusted_wy > adjusted_wx) & (adjusted_wy <= -adjusted_wx);  % top
        idx_loc(2) = (adjusted_wy <= adjusted_wx) & (adjusted_wy <= -adjusted_wx); % right
        idx_loc(3) = (adjusted_wy <= adjusted_wx) & (adjusted_wy > -adjusted_wx);  % bottom
        idx_loc(4) = (adjusted_wy > adjusted_wx) & (adjusted_wy > -adjusted_wx);   % left
        quad_loc = find(idx_loc);

        fly_loc = ~isnan(x_loc); %gives logical for all fly positions in the position matrix
        foodQuad = Q(quad_loc).Mask & fly_loc; % flies in food quad
        nflies = data(exp).T.NumFlies(trial);
        quad_occ = sum(foodQuad,2)./nflies)

        switch quad_loc
            case 1
                foodQuad = 
            case 2
            case 3
            case 4
        end

        % Assign quadrant values to the quadrant matrix
        quadrantMatrix(Q1Mask) = 1;  % Quadrant 1 (Top-left)
        quadrantMatrix(Q2Mask) = 2;  % Quadrant 2 (Top-right)
        quadrantMatrix(Q3Mask) = 3;  % Quadrant 3 (Bottom-right)
        quadrantMatrix(Q4Mask) = 4;  % Quadrant 4 (Bottom-left)
        
        % Display the quadrant classification matrix
        disp('Quadrant classification matrix:');
        disp(quadrantMatrix);


% test where the current food wells to determine which quadrant is which well! (this
% is dynamic and doesn't require a set rule, but allows for the variable well
% locations. 









% Set axis limits for the selected arena
x = data.centre(1);
y = data.centre(2);
r = data.r;
xlimit = [x-(r+50),x+(r+50)];
ylimit = [y-(r+50),y+50+r];

% load the image
currentImg = rgb2gray(read(movieInfo,frame_num));


% PLOT image:
fig = getfig('',1);
set(fig,'color','k')
imshow(currentImg)
xlim(xlimit); ylim(ylimit); 
hold on
imcontrast
    
% plot a yellow point for each fly
x = data.x_loc(exp_idx,:);
y = data.y_loc(exp_idx,:);
scatter(x,y,50,'y','filled')
scatter(x,y,10,'r','filled')







%% 

% Example matrices of points (16x200) for X and Y coordinates
X_points = randi([0, 256], 16, 200);  % Replace with your X points
Y_points = randi([0, 256], 16, 200);  % Replace with your Y points

% Define the center of the circle (different X and Y values)
center = [100, 150];  % Example non-centered circle (X_center = 100, Y_center = 150)

% Adjust the X and Y coordinates relative to the new center
adjustedX = X_points - center(1);
adjustedY = Y_points - center(2);

% Initialize matrix to hold quadrant classification (same size as input matrices)
quadrantMatrix = zeros(size(X_points));

% Define quadrant masks based on the new center
Q1Mask = (adjustedY > adjustedX) & (adjustedY > -adjustedX);   % Top-left
Q2Mask = (adjustedY > adjustedX) & (adjustedY <= -adjustedX);  % Top-right
Q3Mask = (adjustedY <= adjustedX) & (adjustedY <= -adjustedX); % Bottom-right
Q4Mask = (adjustedY <= adjustedX) & (adjustedY > -adjustedX);  % Bottom-left

% Assign quadrant values to the quadrant matrix
quadrantMatrix(Q1Mask) = 1;  % Quadrant 1 (Top-left)
quadrantMatrix(Q2Mask) = 2;  % Quadrant 2 (Top-right)
quadrantMatrix(Q3Mask) = 3;  % Quadrant 3 (Bottom-right)
quadrantMatrix(Q4Mask) = 4;  % Quadrant 4 (Bottom-left)

% Display the quadrant classification matrix
disp('Quadrant classification matrix:');
disp(quadrantMatrix);


