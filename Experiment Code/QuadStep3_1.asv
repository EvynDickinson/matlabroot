
%    GroupDataGUI

%% LOAD: multiple trials that are grouped into a structure
clear; warning off

if strcmpi('Yes', questdlg('Use excel named structure?','','Yes','No', 'Cancel', 'No'))
    % baseFolder = getCloudPath;
    [excelfile, Excel, xlFile] = load_QuadBowlExperiments;
    baseFolder = getCloudPath;
    
    % Select structure to load:
    [~,~,structInfo] = getExcelStructureNames(true);
    ExpGroup = structInfo.StructName;
    ntrials = structInfo.numTrials;
    
    % Make a data folder for structure images
    figDir = [baseFolder 'Data structures\' ExpGroup '\'];
    if ~exist(figDir, 'dir'); mkdir(figDir); end
    
    % Load data from each trial in the structure
    data = [];
    fprintf('\nLoading trials: \n')
    for trial = 1:ntrials
        % print the experiments as they are loaded
        trialExpID = excelfile{structInfo.rowNum(trial), Excel.expID};
        trialDate = excelfile{structInfo.rowNum(trial), Excel.date};
        trialArena = excelfile{structInfo.rowNum(trial), Excel.arena};
        trialName = [trialExpID ' Arena ' trialArena ' ' trialDate];
        disp(trialName)
        
        % build the path for the trial data
        dirc = [baseFolder, trialDate, '\Arena ' trialArena '\analysis\' trialExpID trialArena  ' timecourse data.mat'];
        
        % load data
        todel = load(dirc);
        variList = fieldnames(todel);
    %     todel = load(dirc, varList{:});
        data(trial).trialName = trialName;
        for ii = 1:length(variList)
            data(trial).(variList{ii}) = todel.(variList{ii});
        end
    end

else %select data structure from folder names out of GroupDataGUI:
    [baseFolder, folder] = getCloudPath(3);
    list_dirs = dir(folder); 
    list_dirs = {list_dirs(:).name};
    list_dirs(1:2) = [];
    idx = listdlg('ListString', list_dirs,'ListSize', [250, 400]);
    
    figDir = [folder list_dirs{idx} '/'];
    ExpGroup = list_dirs{idx};
    
    % load the directory list:
    load([figDir 'fileList.mat'])
    
    % extract information
    ntrials = size(T,1);
    dates = T.Date;
    arenas = T.Arena;
    expID = T.ExperimentID;
    
    % load data
    n = cell(1,ntrials);
    data = struct('dist2wells', n, 'wellLabels', n, 'occupancy', n,'nflies',n,'data', n);  
    var2load = fieldnames(data);
    
    for trial = 1:ntrials
        filePath = [baseFolder, dates{trial}, '/Arena ' arenas{trial} '/analysis/'];
        if ~isfolder(filePath)
            filePath = [baseFolder, dates{trial}, '/Arena ' arenas{trial} '/'];
        end
        
        temp = load([filePath expID{trial} arenas{trial} ' timecourse data.mat'], var2load{:});
        for ii = 1:length(var2load)
            try data(trial).(var2load{ii}) = temp.(var2load{ii});
            catch; data(trial).(var2load{ii}) = [];
            end
        end
        disp([expID{trial} arenas{trial}])
    end
end

%Pull and reorganize data within the structure:

pix2mm = 12.8; %conversion from pixels to mm for these videos
    
initial_vars = {'ExpGroup','baseFolder', 'T', 'data', 'figDir', 'filePath',...
                'initial_vars', 'folder', 'ntrials', 'pix2mm'};
clearvars('-except',initial_vars{:})
if questdlg('Save loaded data?')
    save([figDir ExpGroup ' raw'])
end
fprintf('Data loaded\n')

%% General data organization (forward and backwards compatability

% fill out the data structure
for trial = 1:ntrials
    if isempty(data(trial).occupancy)
        data(trial).occupancy = data(trial).data.occupancy;
    end
    if isempty(data(trial).nflies)
        data(trial).nflies = data(trial).data.nflies;
    end
    if isempty(data(trial).wellLabels)
        data(trial).wellLabels = data(trial).data.wellLabels;
    end
    if isempty(data(trial).dist2wells)
        try
            data(trial).dist2wells = data(trial).data.occupancy.dist2wells;
        catch
            for well = 1:4
                data(trial).dist2wells = data(trial).occupancy.dist2wells(well).N(:,1)./pix2mm;
            end
        end
    else
        temp = data(trial).dist2wells;
        data(trial).dist2wells = [];
        for well = 1:4
            data(trial).dist2wells(:,well) = temp(well).N(:,1)./pix2mm;
        end
    end
end

% find the types of food available:
names = [];
for trial = 1:ntrials
    names = unique([data(trial).wellLabels; names]);
end
nfoods = length(names)-1;
foodNames = names;
foodNames(strcmp(names, 'Empty')) = [];

initial_vars{end+1} = 'nfoods';
initial_vars{end+1} = 'foodNames';
clearvars('-except',initial_vars{:})

%% FIGURE: visual check of temperature alignment across the experiments:
fig = figure; hold on
for trial = 1:ntrials
    X = data(trial).occupancy.time;
    Y = data(trial).occupancy.temp;
    plot(X, Y, 'linewidth', 1)
end
xlabel('Time (min)')
ylabel('Temp (\circ)')
title({'temperature alignment across experiments';...
      ['N = ' num2str(ntrials)]})
formatFig(fig, true);

save_figure(fig, [figDir ExpGroup ' temperature alignment'], '-png');

clearvars('-except',initial_vars{:})
fprintf('Next\n')

%% FIGURE: Distance to food vs temperature -- ALL trial lines
sSpan = 360;
fig = figure; hold on
for trial = 1:ntrials
    X = data(trial).occupancy.temp;
    for well = 1:4
        Y = data(trial).dist2wells(:,well);
        % reorder the data by temperature:
        [plotX, idx] = sort(X);
        plot(plotX, smoothdata(Y(idx),'movmean', sSpan), 'linewidth', 1,'color', pullFoodColor(data(trial).wellLabels{well}))
    end
end
ylabel('Distance to well (mm)')
xlabel('Temp (\circC)')
title({'Location from food sources by temperature';...
      ['N = ' num2str(ntrials)]})
formatFig(fig, true);
save_figure(fig, [figDir ExpGroup ' all temp vs distance'], '-png');

clearvars('-except',initial_vars{:})
fprintf('Next\n')

%% FIGURE: Average distance | occupancy vs temp across trials:

inputVar =  questdlg('Which data type to compare?','','distance','occupation probability','Cancel','distance');

food = struct;
switch inputVar
    case 'distance'
        ylab = 'Distance from well (mm)';
        L_loc = 'southwest';
    case 'occupation probability'
        ylab = inputVar;
        L_loc = 'northwest';
    case 'Cancel'
        return
end

%allocate empty data structure & set params
for ii = 1:nfoods+1
    food(ii).N = [];
    if ii <= nfoods
        food(ii).name = foodNames{ii};
    else 
        food(ii).name = 'Empty';
    end
end
for trial = 1:ntrials
    x = data(trial).occupancy.temp;
    for well = 1:4
        switch inputVar
            case 'distance'
                y = data(trial).dist2wells(:,well);
            case 'occupation probability'
                y = data(trial).occupancy.occ(:,well);
        end
        % empty food well:
        wellID = data(trial).wellLabels{well};
        if contains(wellID,'Empty')
            food(nfoods+1).N = [food(nfoods+1).N; x, y];
        else 
            loc = find(strcmp(wellID,foodNames));
            food(loc).N = [food(loc).N; x, y];
        end
    end
end 

% Temperature range and bin size formatting
[threshHigh, threshLow] = getTempThresholds;
binSpace = str2double(cell2mat(inputdlg('Bin size for temperature?','',[1,35],{'1'}))); 
t_roi = floor(threshLow):binSpace:ceil(threshHigh); 
if t_roi(end)<ceil(threshHigh)
    t_roi(end+1) = ceil(threshHigh) + binSpace;
end
    
% Pull plotting data:
for ii = 1:nfoods+1 %each food type
    % cut off the high and low ends of data (to clean):
    loc = food(ii).N(:,1)>threshHigh | food(ii).N(:,1)<threshLow;
    food(ii).N(loc,:) = [];
    % sort all the data by temperature:
    food(ii).N(:,3) = discretize(food(ii).N(:,1),t_roi);
    for tt = 1:length(t_roi)
        loc = food(ii).N(:,3)==tt;
        food(ii).avg(tt) = mean(food(ii).N(loc,2),1,'omitnan');
        food(ii).err(tt) = std(food(ii).N(loc,2),0,1,'omitnan')/sqrt(ntrials);
    end
end
    
% FIGURE: plot the avg. temp vs. distance data
CList = Color('SteelBlue', 'Navy', nfoods);
CList(nfoods+1,:) = Color('White');

fig = figure; set(fig,'pos', [67 82 675 692]);
hold on
for ii = 1:nfoods+1
    kolor = CList(ii,:);
    x = t_roi;
    y = food(ii).avg;
%     y_err = food(ii).err;
%     fill_data = error_fill(x,y, y_err);
%     h = fill(fill_data.X, fill_data.Y, kolor, 'EdgeColor','none');
%     set(h, 'facealpha', 0.35)
    plot(x, y, 'Color', kolor, 'LineWidth', 2)
%     plot(x, y+y_err, 'Color', kolor, 'LineWidth', 0.25)
%     plot(x, y-y_err, 'Color', kolor, 'LineWidth', 0.25)
end
%Labels:
% xlim([7,20])
xlabel('temperature (\circC)')
ylabel(ylab)
title(strrep(ExpGroup,'_',' '))
formatFig(fig,true);
ax = gca;
set(ax, 'FontSize', 18)
str = strrep([foodNames; 'Empty'],'_',' ');
legend(str,'textcolor', 'w', 'location', L_loc, 'box', 'off','fontsize',12)

save_figure(fig, [figDir ExpGroup ' temp vs ' inputVar ' bin size ' num2str(binSpace)], '-png');
clearvars('-except',initial_vars{:})

%% FIGURE: Average movement | cluserting | eccenvs temp across trials:

inputVar =  questdlg('Which data type to compare?','','movement','clustering','eccentricity','movement');
switch inputVar
    case 'movement'
        ylab = 'movement (au)';
        L_loc = 'southeast';
    case 'clustering'
        ylab = 'Inter-fly-distance (mm)';
        L_loc = 'northwest';
    case 'eccentricity'
        ylab = 'eccentricity (mm)';
        L_loc = 'northwest';
    case ''
        return
end

%allocate empty data structure & set params
food = struct;
food.N = [];
for trial = 1:ntrials
    switch inputVar
        case 'movement'
            x = data(trial).occupancy.temp(1:end-1);
            y = data(trial).occupancy.movement;
        case 'clustering'
            y = data(trial).occupancy.IFD';
            x = data(trial).occupancy.temp;
        case 'eccentricity'
            y = data(trial).occupancy.eccentricity;
            x = data(trial).occupancy.temp;
    end 
    food.N = [food.N; x,y];
end 

% Temperature range and bin size formatting
[threshHigh, threshLow] = getTempThresholds;
binSpace = str2double(cell2mat(inputdlg('Bin size for temperature?','',[1,35],{'1'}))); 
t_roi = floor(threshLow):binSpace:ceil(threshHigh); 
if t_roi(end)<ceil(threshHigh)
    t_roi(end+1) = ceil(threshHigh) + binSpace;
end
    
% cut off the high and low ends of data (to clean):
loc = food.N(:,1)>threshHigh | food.N(:,1)<threshLow;
food.N(loc,:) = [];
% sort all the data by temperature:
food.N(:,3) = discretize(food.N(:,1),t_roi);
for tt = 1:length(t_roi)
    loc = food.N(:,3)==tt;
    food.avg(tt) = mean(food.N(loc,2),1,'omitnan');
    food.err(tt) = std(food.N(loc,2),0,1,'omitnan')/sqrt(ntrials);
end

    
% FIGURE: plot the avg. temp vs. distance data
kolor = Color('Teal');

fig = figure; set(fig,'pos', [67 82 675 692]);
hold on
x = t_roi;
y = food.avg;
y_err = food.err;
plot(x, y, 'Color', kolor, 'LineWidth', 2)
plot(x, y+y_err, 'Color', kolor, 'LineWidth', 0.25)
plot(x, y-y_err, 'Color', kolor, 'LineWidth', 0.25)

%Labels:
% xlim([7,20])
xlabel('temperature (\circC)')
ylabel(ylab)
title(strrep(ExpGroup,'_',' '))
formatFig(fig,true);
ax = gca;
set(ax, 'FontSize', 18)

save_figure(fig, [figDir ExpGroup ' temp vs ' inputVar ' bin size ' num2str(binSpace)], '-png');
clearvars('-except',initial_vars{:})








%% FIGURE: Temperature hysteresis -- does temp ramp direction matter?

[threshHigh, threshLow] = getTempThresholds;

% %%-----plot the alignment of the increase|decreasing areas for a single trial------
% trial = 1;
% tPoints = getTempTurnPoints(T.TempProtocol{trial});
% fig = figure; hold on
% plot(data(trial).occupancy.temp,'color', 'w')
% y = rangeLine(fig);
% for ii = 1:tPoints.nUp
%     plot(tPoints.up(ii,:),[y,y],'color', Color('red'),'linewidth',1)
% end
% v_line(reshape(tPoints.up,numel(tPoints.up),1),'w')
% for ii = 1:tPoints.nUp
%     plot(tPoints.down(ii,:),[y,y],'color', Color('deepskyblue'),'linewidth',1)
% end
% % scatter(tPoints.UpROI,27*ones(1,length(tPoints.UpROI)),10,'g','filled')
% % scatter(tPoints.DownROI,27*ones(1,length(tPoints.DownROI)),10,'r','filled')
% ylabel('temp (\circC)')
% xlabel('time (data points)')
% title(ExpGroup)
% fig = formatFig(fig, true);
% save_figure(fig,...
%     [figDir ExpGroup ' temp ramp delineation for ' T.TempProtocol{trial}], '-png');
% %-------------------------------------------------------------------------

% Pull the data from segments 
[plant, yeast, empty] = deal(struct('up', [], 'down',[]));
for trial = 1:ntrials
 
    tPoints = getTempTurnPoints(T.TempProtocol{trial}); %accomodates multiple temp protocols within the data group

    X = data(trial).occupancy.temp; % temperature
    for well = 1:4
        [~,K] = pullFoodColor(data(trial).wellLabels{well});
        % pull the dist2well data for each trial
        try Y = data(trial).occupancy.dist2wells(well).N(:,1)./pix2mm; %distance to wells
        catch; Y = data(trial).dist2wells(well).N(:,1)./pix2mm;
        end
        raw = [X',Y];
        % sort the data by food type
        switch K
            case 1
                plant.up = [plant.up; raw(tPoints.UpROI,:)];
                plant.down = [plant.down; raw(tPoints.DownROI,:)];
            case 2
                yeast.up = [yeast.up; raw(tPoints.UpROI,:)];
                yeast.down = [yeast.down; raw(tPoints.DownROI,:)];
            case 3
                empty.up = [empty.up; raw(tPoints.UpROI,:)];
                empty.down = [empty.down; raw(tPoints.DownROI,:)];
        end
    end
end

% Organize data for plotting - bin by temp (deg)
emptyData = false(1,3);
plotData = [];
t_roi = floor(threshLow):ceil(threshHigh); 
for K = 1:3 %food type
    for type = 1:2
        % pull appropriate data:
        switch K
            case 1 %plant
                UpData = plant.up;
                DownData = plant.down;
            case 2 %yeast
                UpData = yeast.up;
                DownData = yeast.down;
            case 3 %empty
                UpData = empty.up;
                DownData = empty.down;
        end
        if isempty(UpData) || isempty(DownData)
            emptyData(K) = true;
            continue 
        end
        if type == 1 
            inputData = UpData;
        else 
            inputData = DownData;
        end
%         [loc,idx,cnt_unique,unique_a,len,mt] = deal([]);
        % cut off the high and low ends of data (to clean):
        loc = inputData(:,1)>threshHigh | inputData(:,1)<threshLow;
        inputData(loc,:) = [];
        
        % sort all the data by temperature:
        idx = discretize(inputData(:,1),t_roi);
        [cnt_unique, unique_a] = hist(idx,unique(idx));
        len = max(cnt_unique);
        mt = nan(len,length(unique_a));
        for tt = 1:length(unique_a)
            cue = unique_a(tt); %index number
            loc = idx==cue;
            mt(1:sum(loc),tt) = inputData(loc,2);
            y_err(tt) = std(inputData(loc,2));
            plotData(K,type).y_avg(tt) = mean(inputData(loc,2));
        end
        plotData(K,type).y_err = y_err./sqrt(ntrials);
        plotData(K,type).xdata = t_roi(unique_a);
        inputData = [];
    end
end
 
% PLOT the grouped & binned data points :
nPlots = sum(~emptyData);
nrows = 1; ncols = nPlots;
titleList = {'Plant', 'Yeast', 'Empty'};
CList = {'red', 'deepskyblue'}; %heating and cooling colors

ii = 0;
fig = figure; set(fig, 'pos', [132 83 365*nPlots 693]);
for K = 1:3
    % skips absent food types
    if emptyData(K)
        continue
    else
        ii = ii+1;
    end
    subplot(nrows, ncols, ii)
    hold on
    for type = 1:2
        kolor = Color(CList{type});
        x = plotData(K,type).xdata;
        y = plotData(K,type).y_avg;
        yerr = plotData(K,type).y_err;
        fill_data = error_fill(x, y, yerr);
        h = fill(fill_data.X, fill_data.Y, kolor, 'EdgeColor','none');
          set(h, 'facealpha', 0.2)
        plot(x,y,'color', kolor, 'linewidth', 2)
    end
    ylimits(ii,:) = ylim;
    xlabel('temperature (\circC)')
    ylabel('distance from well (mm)')
    title(titleList{K})
end
fig = formatFig(fig,true, [nrows,ncols]);
%set uniform y axis
for ii = 1:nPlots
subplot(nrows,ncols,ii)
ylim([min(ylimits(:,1)),max(ylimits(:,2))])
end
l = legend({'SEM','Heating', 'SEM','Cooling'});
set(l, 'textcolor', 'w','position', [0.5997 0.1556 0.1781 0.1176])
save_figure(fig, [figDir ExpGroup ' temp hysteresis'], '-png');

clearvars('-except',initial_vars{:})


%% PROCESS: auto generate increasing and decreasing temp ramp regions
% step 1: smooth temp ramp and label temp points as increasing or decreasing
X = data(1).occupancy.temp; % temperature
Y = data(1).occupancy.dist2wells(1).N(:,1); %distance to wells

temp = smoothdata(X,'movmean',180); % this is the avg. temp for the previous 180 data points (except at start and end)
direct = diff(temp); % this tells me if the previous point was decreasing or increasing
increase = smoothdata(direct,'movmean',360)>0;
decrease = smoothdata(direct,'movmean',360)<0;


% 10 minute bins for determining temp history
dur = 10*60*3; %min * sec/min * frames/sec
a = smoothdata(increase,'movmean',dur)>0.75; %increasing temp points
b = smoothdata(decrease,'movmean',dur)>0.75;

upPoints = (a==~b);


figure; 
subplot(3,1,1) 
plot(temp)
title('temp')
subplot(3,1,2); hold on
plot(upPoints, 'color', 'g')
plot(a)
title('increasing')
subplot(3,1,3);
plot(b)
title('decreasing')



figure; 
subplot(3,1,1) 
plot(temp)
subplot(3,1,2)
plot(direct)
subplot(3,1,3);
plot(increase)


figure;
plot(smoothdata(increase,'movmean',90))










































